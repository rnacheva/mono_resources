# -*- coding: utf-8 -*-
"""Category-extraction-from-OWL.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/rnacheva/mono_resources/blob/main/Category-extraction-from-OWL.ipynb
"""



"""# Task
Extract categories for digital accessibility assessment from the OWL file "/content/ontology-full-data-process.owl".

## Load and parse the owl file

### Subtask:
Use a library like `rdflib` to load and parse the OWL file.

**Reasoning**:
Import the necessary library and load the OWL file into a graph object.
"""

from rdflib import Graph

g = Graph()
g.parse("/content/ontology-full-data-process.owl", format='xml')

"""**Reasoning**:
The previous command failed because the `rdflib` library is not installed. Install the library using pip.


"""

!pip install rdflib

"""**Reasoning**:
Now that `rdflib` is installed, retry loading the OWL file into a graph object.


"""

from rdflib import Graph

g = Graph()
g.parse("/content/ontology-full-data-process.owl", format='xml')

"""## Identify relevant classes/properties

### Subtask:
Analyze the ontology structure to identify the classes and properties that represent categories for digital accessibility assessment.

**Reasoning**:
Iterate through the triples in the graph and print some to understand the ontology structure and identify potential categories.
"""

for i, (s, p, o) in enumerate(g):
    if i < 20:  # Print the first 20 triples
        print(s, p, o)
    else:
        break

"""**Reasoning**:
Based on the printed triples, the subjects with the predicate `http://www.w3.org/1999/02/22-rdf-syntax-ns#type` and object `http://www.w3.org/2002/07/owl#Class` seem to represent the categories. I will identify and list these classes.


"""

accessibility_categories = set()
for s, p, o in g:
    if p == 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type' and o == 'http://www.w3.org/2002/07/owl#Class':
        accessibility_categories.add(str(s))

print("Identified Accessibility Categories (Classes):")
for category in accessibility_categories:
    print(category)

"""## Extract categories

### Subtask:
Extract the names or identifiers of the identified categories.

**Reasoning**:
Iterate through the identified accessibility category URIs and extract the category name from each URI, then print the list of extracted names.
"""

category_names = []
for uri in accessibility_categories:
    # Extract the last part of the URI after the last '#' or '/'
    name = uri.split('#')[-1].split('/')[-1]
    category_names.append(name)

print("Extracted Accessibility Category Names:")
for name in category_names:
    print(name)

"""## Present the categories

### Subtask:
Display the extracted categories.

**Reasoning**:
Display the extracted category names by printing the list.
"""

print("Extracted Accessibility Category Names:")
for name in category_names:
    print(name)

"""**Reasoning**:
The category names were not printed in the previous step, likely because the `category_names` list was empty. Re-running the extraction step to populate the list before printing.


"""

category_names = []
for uri in accessibility_categories:
    # Extract the last part of the URI after the last '#' or '/'
    name = uri.split('#')[-1].split('/')[-1]
    category_names.append(name)

print("Extracted Accessibility Category Names:")
for name in category_names:
    print(name)

"""**Reasoning**:
The `category_names` list is still empty after re-running the extraction code. This suggests that the `accessibility_categories` set is also empty. I need to re-examine how `accessibility_categories` is populated to understand why no categories are being identified.


"""

print("Number of identified accessibility categories:", len(accessibility_categories))
if len(accessibility_categories) == 0:
    print("No accessibility categories were identified. Please check the previous steps where accessibility_categories is populated.")

"""## Identify relevant classes/properties retry 1

### Subtask:
Retry identifying relevant classes/properties by analyzing the ontology structure more thoroughly to pinpoint classes or properties that represent digital accessibility assessment categories, considering the previous failure where no categories were identified.

**Reasoning**:
Iterate through all triples in the graph `g` to understand the predicates and objects used, looking for patterns that might indicate categories or relevant concepts related to digital accessibility. Print a sample of unique predicates to get an overview of the relationships defined in the ontology.
"""

unique_predicates = set()
for s, p, o in g:
    unique_predicates.add(str(p))

print("Sample of unique predicates:")
for i, predicate in enumerate(list(unique_predicates)[:20]):
    print(predicate)

"""**Reasoning**:
Based on the observed predicates, which include `http://www.w3.org/1999/02/22-rdf-syntax-ns#type`, `http://www.w3.org/2000/01/rdf-schema#comment`, and `http://www.w3.org/2000/01/rdf-schema#label`, formulate a more specific condition to identify potential accessibility categories. Given the lack of specific accessibility predicates in the sample, a broader approach of identifying subclasses of `owl:Class` or looking for specific keywords in labels or comments might be necessary. Iterate through the graph again, applying the refined condition to identify potential accessibility categories. Store the identified subjects (URIs) in the `accessibility_categories` set. After identifying potential categories, print the count of identified categories to confirm if the set was populated and print the URIs in the `accessibility_categories` set to inspect the identified categories.


"""

accessibility_categories = set()
for s, p, o in g:
    # Check for subjects that are explicitly typed as owl:Class
    if p == 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type' and o == 'http://www.w3.org/2002/07/owl#Class':
        accessibility_categories.add(str(s))
    # Alternatively, check for subjects with rdfs:label or rdfs:comment containing accessibility-related keywords
    if p == 'http://www.w3.org/2000/01/rdf-schema#label' or p == 'http://www.w3.org/2000/01/rdf-schema#comment':
        if isinstance(o, str) and ('access' in o.lower() or 'accessibility' in o.lower()):
            accessibility_categories.add(str(s))


print("Number of identified accessibility categories:", len(accessibility_categories))
print("Identified Accessibility Categories (URIs):")
for category in accessibility_categories:
    print(category)

"""## Identify relevant classes/properties retry 2

### Subtask:
Retry identifying relevant classes/properties by further analyzing the ontology structure to pinpoint classes or properties that represent digital accessibility assessment categories, considering the previous failures where no categories were identified.

**Reasoning**:
Identify all unique predicates in the graph `g` to get a comprehensive overview of the relationships and properties used in the ontology. Then examine the types of objects associated with the identified predicates to understand the nature of the data. Look for predicates or classes that seem semantically related to "accessibility", "assessment", "criteria", "guideline", "requirement", or similar terms, even if they are not explicitly labeled as such, by printing a sample of triples containing these predicates or classes.
"""

unique_predicates = set()
for s, p, o in g:
    unique_predicates.add(str(p))

print("Sample of unique predicates:")
for i, predicate in enumerate(list(unique_predicates)[:20]):
    print(predicate)

print("\nExamining object types for a sample of predicates:")
for i, predicate_uri in enumerate(list(unique_predicates)[:10]):
    print(f"\nPredicate: {predicate_uri}")
    sample_objects = set()
    for s, p, o in g.triples((None, URIRef(predicate_uri), None)):
        sample_objects.add(type(o))
        if len(sample_objects) >= 5: # Limit the number of object types shown
            break
    print(f"  Sample object types: {list(sample_objects)}")

print("\nSample triples containing accessibility-related terms:")
accessibility_terms = ["access", "accessibility", "assess", "assessment", "criteria", "guideline", "requirement"]
count = 0
for s, p, o in g:
    if any(term in str(s).lower() for term in accessibility_terms) or \
       any(term in str(p).lower() for term in accessibility_terms) or \
       any(term in str(o).lower() for term in accessibility_terms):
        print(s, p, o)
        count += 1
        if count >= 20: # Print a sample of 20 triples
            break

"""**Reasoning**:
The previous command failed because `URIRef` was not defined. I need to import `URIRef` from `rdflib` to fix this error and then re-run the code to identify predicates, object types, and sample triples containing accessibility-related terms.


"""

from rdflib import URIRef

unique_predicates = set()
for s, p, o in g:
    unique_predicates.add(str(p))

print("Sample of unique predicates:")
for i, predicate in enumerate(list(unique_predicates)[:20]):
    print(predicate)

print("\nExamining object types for a sample of predicates:")
for i, predicate_uri in enumerate(list(unique_predicates)[:10]):
    print(f"\nPredicate: {predicate_uri}")
    sample_objects = set()
    for s, p, o in g.triples((None, URIRef(predicate_uri), None)):
        sample_objects.add(type(o))
        if len(sample_objects) >= 5: # Limit the number of object types shown
            break
    print(f"  Sample object types: {list(sample_objects)}")

print("\nSample triples containing accessibility-related terms:")
accessibility_terms = ["access", "accessibility", "assess", "assessment", "criteria", "guideline", "requirement"]
count = 0
for s, p, o in g:
    if any(term in str(s).lower() for term in accessibility_terms) or \
       any(term in str(p).lower() for term in accessibility_terms) or \
       any(term in str(o).lower() for term in accessibility_terms):
        print(s, p, o)
        count += 1
        if count >= 20: # Print a sample of 20 triples
            break

"""**Reasoning**:
Based on the examination of predicates and sample triples, it appears that subjects with the type `http://www.w3.org/2002/07/owl#Class` and those whose URIs or labels contain accessibility-related terms are good candidates for accessibility assessment categories. I will iterate through the graph again and collect these subjects.


"""

accessibility_categories = set()
accessibility_terms = ["access", "accessibility", "assess", "assessment", "criteria", "guideline", "requirement"]

for s, p, o in g:
    # Condition 1: Subject is an owl:Class
    if p == 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type' and o == 'http://www.w3.org/2002/07/owl#Class':
        accessibility_categories.add(str(s))

    # Condition 2: Subject URI or rdfs:label contains accessibility-related terms
    if any(term in str(s).lower() for term in accessibility_terms):
         accessibility_categories.add(str(s))
    if p == 'http://www.w3.org/2000/01/rdf-schema#label' and isinstance(o, str) and any(term in o.lower() for term in accessibility_terms):
        accessibility_categories.add(str(s))


print("Number of identified accessibility categories:", len(accessibility_categories))
print("Sample of identified accessibility categories (URIs):")
for i, category in enumerate(list(accessibility_categories)[:20]):
    print(category)

"""## Extract categories

### Subtask:
Extract the names or identifiers of the identified categories.

**Reasoning**:
The previous step successfully identified accessibility categories as URIs and stored them in the `accessibility_categories` set. Now, I need to extract the names from these URIs and store them in a list, then print them according to the instructions.
"""

category_names = []
for uri in accessibility_categories:
    # Extract the last part of the URI after the last '#' or '/'
    name = uri.split('#')[-1].split('/')[-1]
    category_names.append(name)

print("Extracted Accessibility Category Names:")
for name in category_names:
    print(name)

"""## Present the categories

### Subtask:
Display the extracted categories.

**Reasoning**:
Iterate through the `category_names` list and print each category name on a new line.
"""

for name in category_names:
    print(name)

"""## Summary:

### Data Analysis Key Findings

*   The initial attempts to identify accessibility categories by looking for `owl:Class` types or keywords in `rdfs:label` and `rdfs:comment` failed to find any categories.
*   A more thorough analysis of the ontology's predicates and triples revealed that subjects typed as `owl:Class` or whose URIs/labels contained accessibility-related terms like "access", "accessibility", "assess", "assessment", "criteria", "guideline", or "requirement" were relevant categories.
*   Using this refined approach, 50 potential accessibility assessment categories were successfully identified within the OWL file.
*   The names of these categories were extracted by taking the last part of their URIs after the '#' or '/' characters.

### Insights or Next Steps

*   The ontology's structure required a combined approach of checking for `owl:Class` types and keyword presence in URIs/labels to effectively identify the relevant categories.
*   Further analysis could involve examining the relationships between these identified categories to understand the hierarchical structure or dependencies within the accessibility assessment framework defined by the ontology.

"""